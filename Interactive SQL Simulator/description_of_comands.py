# SELECT 'столбцы или * для выбора всех столбцов; обязательно'
# FROM 'таблица; обязательно'
# WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'
# GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'
# HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'
# ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
# DISTINCT - получить уникальные строки (отличающиеся друг от друга любым отображаемым полем).
# Работает чуть быстрее.
# GROUP BY - сгруппировать по какому-либо признаку,
# при этом можно использовать агрегатные функции SUM, AVG, MAX и т.д.
#
# IF(логическое_выражение, выражение_1, выражение_2)
# Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1,
# в противном случае –  значение выражения_2.
# Все три параметра IF() являются обязательными.
#
# операторы сравнения (
# равно «=»,
# не равно «<>»,
# больше «>»,
# меньше «<»,
# больше или равно«>=»,
# меньше или равно «<=»
# )
#
# после ключевого слова WHERE кроме операторов сравнения  и выражений может включать
# логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки,
# изменяющие приоритеты выполнения операций.
#
# Приоритеты операций:
# 1 круглые скобки
# 2 умножение  (*),  деление (/)
# 3 сложение  (+), вычитание (-)
# 4 операторы сравнения (=, >, <, >=, <=, <>)
# 5 NOT
# 6 AND
# 7 OR
#
# после ключевого слова WHERE может включать операторы  BETWEEN и IN.
# Приоритет  у этих операторов такой же как у операторов сравнения,
# то есть они выполняются раньше, чем NOT, AND, OR
#
# При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать
# отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются
# имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец,
# сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы.
# По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением
# сортировки вручную,
# после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию).
#
#
# Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и
# не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение),
# а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны.
# При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами,
# указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.
#
#
# % 	Любая строка, содержащая ноль или более символов
# SELECT * FROM book WHERE author LIKE '%М.%' выполняет поиск и выдает все книги, инициалы
# авторов которых содержат «М.»
# _ (подчеркивание)	Любой одиночный символ SELECT * FROM book WHERE title LIKE 'Поэм_'
# выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.
#
# Чтобы указать, что в названии должен быть хотя бы один символ,
# можно использовать один из эквивалентных шаблонов:
#
#  "_%" - сначала идет символ, а за ним любое количество символов;
# "%_" - сначала идет любое количество символов, а затем обязательный символ;
# "%_%" - сначала идет любое количество символов, потом обязательный символ,
# а за ним любое количество символов.
#
# В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных
# запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется
# ключевое слово HAVING , которое размещается после оператора GROUP BY
#
# Если столбец указан в SELECT БЕЗ применения групповой функции,
# то он обязательно должен быть указан и в GROUP BY.Иначе получим ошибку.
#
# WHERE и HAVING могут использоваться в одном запросе.
# При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:
#
# 1 FROM
# 2 WHERE
# 3 GROUP BY
# 4 HAVING
# 5 SELECT
# 6 ORDER BY
# Сначала определяется таблица, из которой выбираются данные (FROM), затем из этой таблицы
# отбираются записи в соответствии с условием  WHERE, выбранные данные агрегируются (GROUP BY),
# из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING.
# Потом формируются данные результирующей выборки, как это указано после SELECT
# ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется,
# как указано после ORDER BY.
#
# Важно! Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку.
# Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе.
# Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в WHERE нельзя использовать
# имена выражений из SELECT. Просто SELECT выполняется компилятором позже, чем WHERE, поэтому ему
# неизвестно, какое там выражение написано.
#
# Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора
# записей основного запроса.
#
# Вложенный запрос имеет следующие компоненты:
# ключевое слово SELECT  после которого указываются имена столбцов или выражения
# (чаще всего список содержит один элемент) ;
# ключевое слово FROM и имя таблицы, из которой выбираются данные;
# необязательное предложение WHERE;
# необязательное предложение GROUP BY:
# необязательное предложение HAVING.
# Вложенные запросы  могут включаться в WHERE или HAVING так
# (в квадратных скобках указаны необязательные элементы, через | – один из элементов):
#
# WHERE | HAVING выражение оператор_сравнения (вложенный запрос);
# WHERE | HAVING выражение, включающее вложенный запрос;
# WHERE | HAVING выражение [NOT] IN (вложенный запрос);
# WHERE | HAVING выражение  оператор_сравнения  ANY | ALL (вложенный запрос).
# Также вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT.
#
#  Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора
#  записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).
# # Операторы ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим
# набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца,
# возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения),
# с которым происходит сравнение.
# # При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых
# выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса.
# Как работает оператор ANY:
# # amount > ANY (10, 12) эквивалентно amount > 10
# # amount < ANY (10, 12) эквивалентно amount < 12
# # amount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)
# # amount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12
#
# При использовании оператора ALL в результирующую таблицу будут включены все записи, для которых
# выражение со знаком отношения верно для всех элементов результирующего запроса.
# Как работает оператор ALL:
# # amount > ALL (10, 12) эквивалентно amount > 12
# # amount < ALL (10, 12) эквивалентно amount < 10
# # amount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно
# (amount = 10) AND (amount = 12)
# amount <> ALL (10, 12) вернет все записи кроме тех,  в которых amount равно 10 или 12
#
# # Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше
# (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как
# эти операторы работают. В запросах так записывать нельзя.
#
# Вложенный запрос может располагаться после ключевого слова SELECT. В этом случае
# результат выполнения запроса выводится в отдельном столбце результирующей таблицы.
# При этом результатом запроса может быть только одно значение, тогда оно будет
# повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.
#
# Допускается вставка нескольких записей одновременно,
# для этого используется SQL запрос следующего вида:
#
# INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
# VALUES
#     (значение_1_1, значение_1_2, ..., значение_1_N),
#     (значение_2_1, значение_2_2, ..., значение_2_N),
#     ...
#     (значение_M_1, значение_M_2, ..., значение_M_N);
#
# С помощью запроса на добавление можно не только добавить в таблицу конкретные значения
# (список VALUES), но и записи из другой таблицы, отобранные с помощью запроса на выборку.
# В этом случае вместо раздела VALUES записывается запрос на выборку, начинающийся с SELECT.
# В нем можно использовать WHERE, GROUP BY, ORDER BY.
# # Правила соответствия между полями таблицы и вставляемыми значениями из запроса:
# # количество полей в таблице и количество полей в запросе должны совпадать;
# должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках,
# поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы,
# второй – ко второму столбцу и т.д. типы столбцов запроса должны быть совместимы с типами
# данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL,
# обратная операция – недопустима).
#
# Под обновлением данных подразумевается изменение значений в существующих записях таблицы.
# При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы),
# так и правка значения поля отдельной строки.
# # Изменение записей в таблице реализуется с помощью запроса UPDATE.
# Простейший запрос на  обновление выглядит так:
# # UPDATE таблица SET поле = выражение
# где
# таблица – имя таблицы, в которой будут проводиться изменения;
# поле – поле таблицы, в которое будет внесено изменение;
# выражение – выражение,  значение которого будет занесено в поле.
# С помощью запросов на обновление можно изменять не все записи в таблице , а только часть из них.
# Для этого в запрос включается ключевое слово WHERE, после которого указывается условие
# отбора строк для изменения.
#
# В запросах на обновление можно использовать несколько таблиц, но тогда для столбцов,
# имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например,
# book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
# все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
# в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.
#
# Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы.
# Простейший запрос на удаление имеет вид:
# DELETE FROM таблица;
# Этот запрос удаляет все записи из указанной после FROM таблицы.
# Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют
# условию, указанному после ключевого слова WHERE:
# DELETE FROM таблица
# WHERE условие;
#

