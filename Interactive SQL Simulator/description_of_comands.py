# SELECT 'столбцы или * для выбора всех столбцов; обязательно'
# FROM 'таблица; обязательно'
# WHERE 'условие/фильтрация, например, city = 'Moscow'; необязательно'
# GROUP BY 'столбец, по которому хотим сгруппировать данные; необязательно'
# HAVING 'условие/фильтрация на уровне сгруппированных данных; необязательно'
# ORDER BY 'столбец, по которому хотим отсортировать вывод; необязательно'
# DISTINCT - получить уникальные строки (отличающиеся друг от друга любым отображаемым полем).
# Работает чуть быстрее.
# GROUP BY - сгруппировать по какому-либо признаку,
# при этом можно использовать агрегатные функции SUM, AVG, MAX и т.д.
#
# IF(логическое_выражение, выражение_1, выражение_2)
# Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1,
# в противном случае –  значение выражения_2.
# Все три параметра IF() являются обязательными.
#
# операторы сравнения (
# равно «=»,
# не равно «<>»,
# больше «>»,
# меньше «<»,
# больше или равно«>=»,
# меньше или равно «<=»
# )
#
# после ключевого слова WHERE кроме операторов сравнения  и выражений может включать
# логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки,
# изменяющие приоритеты выполнения операций.
#
# Приоритеты операций:
# 1 круглые скобки
# 2 умножение  (*),  деление (/)
# 3 сложение  (+), вычитание (-)
# 4 операторы сравнения (=, >, <, >=, <=, <>)
# 5 NOT
# 6 AND
# 7 OR
#
# после ключевого слова WHERE может включать операторы  BETWEEN и IN.
# Приоритет  у этих операторов такой же как у операторов сравнения,
# то есть они выполняются раньше, чем NOT, AND, OR
#
# При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать
# отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются
# имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец,
# сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы.
# По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением
# сортировки вручную,
# после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию).
#
#
# Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и
# не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение),
# а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны.
# При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами,
# указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.
#
#
# % 	Любая строка, содержащая ноль или более символов
# SELECT * FROM book WHERE author LIKE '%М.%' выполняет поиск и выдает все книги, инициалы
# авторов которых содержат «М.»
# _ (подчеркивание)	Любой одиночный символ SELECT * FROM book WHERE title LIKE 'Поэм_'
# выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.
#
# Чтобы указать, что в названии должен быть хотя бы один символ,
# можно использовать один из эквивалентных шаблонов:
#
#  "_%" - сначала идет символ, а за ним любое количество символов;
# "%_" - сначала идет любое количество символов, а затем обязательный символ;
# "%_%" - сначала идет любое количество символов, потом обязательный символ,
# а за ним любое количество символов.
#
# В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных
# запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется
# ключевое слово HAVING , которое размещается после оператора GROUP BY
#
# Если столбец указан в SELECT БЕЗ применения групповой функции,
# то он обязательно должен быть указан и в GROUP BY.Иначе получим ошибку.
#
# WHERE и HAVING могут использоваться в одном запросе.
# При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:
#
# 1 FROM
# 2 WHERE
# 3 GROUP BY
# 4 HAVING
# 5 SELECT
# 6 ORDER BY
# Сначала определяется таблица, из которой выбираются данные (FROM), затем из этой таблицы
# отбираются записи в соответствии с условием  WHERE, выбранные данные агрегируются (GROUP BY),
# из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING.
# Потом формируются данные результирующей выборки, как это указано после SELECT
# ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется,
# как указано после ORDER BY.
#
# Важно! Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку.
# Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе.
# Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в WHERE нельзя использовать
# имена выражений из SELECT. Просто SELECT выполняется компилятором позже, чем WHERE, поэтому ему
# неизвестно, какое там выражение написано.
#
# Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора
# записей основного запроса.
#
# Вложенный запрос имеет следующие компоненты:
# ключевое слово SELECT  после которого указываются имена столбцов или выражения
# (чаще всего список содержит один элемент) ;
# ключевое слово FROM и имя таблицы, из которой выбираются данные;
# необязательное предложение WHERE;
# необязательное предложение GROUP BY:
# необязательное предложение HAVING.
# Вложенные запросы  могут включаться в WHERE или HAVING так
# (в квадратных скобках указаны необязательные элементы, через | – один из элементов):
#
# WHERE | HAVING выражение оператор_сравнения (вложенный запрос);
# WHERE | HAVING выражение, включающее вложенный запрос;
# WHERE | HAVING выражение [NOT] IN (вложенный запрос);
# WHERE | HAVING выражение  оператор_сравнения  ANY | ALL (вложенный запрос).
# Также вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT.
#
#  Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора
#  записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).
# # Операторы ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим
# набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца,
# возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения),
# с которым происходит сравнение.
# # При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых
# выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса.
# Как работает оператор ANY:
# # amount > ANY (10, 12) эквивалентно amount > 10
# # amount < ANY (10, 12) эквивалентно amount < 12
# # amount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)
# # amount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12
#
# При использовании оператора ALL в результирующую таблицу будут включены все записи, для которых
# выражение со знаком отношения верно для всех элементов результирующего запроса.
# Как работает оператор ALL:
# # amount > ALL (10, 12) эквивалентно amount > 12
# # amount < ALL (10, 12) эквивалентно amount < 10
# # amount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно
# (amount = 10) AND (amount = 12)
# amount <> ALL (10, 12) вернет все записи кроме тех,  в которых amount равно 10 или 12
#
# # Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше
# (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как
# эти операторы работают. В запросах так записывать нельзя.
#
# Вложенный запрос может располагаться после ключевого слова SELECT. В этом случае
# результат выполнения запроса выводится в отдельном столбце результирующей таблицы.
# При этом результатом запроса может быть только одно значение, тогда оно будет
# повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.
